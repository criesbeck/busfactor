'use strict';

// Which files and actions to track
// This says to only track Add, Change, Modify to JavaScript, HTML, CSS, and YAML files
const EDIT_PAT = /^[ACM]\s+(.*[.](?:js|jsx|ts|tsx|css|html?|yml))$/;

// What threshold for being an active contributor. Range: 0 to 1.
// This says 5%
const THRESHOLD = 0.05;

const count = (lst, fn) => (
  lst.reduce((n, x) => fn(x) ? n + 1 : n, 0)
);

// decay-based activity
const halfLife = 7;
const lambda = Math.log(2) / halfLife;
const day = 24 * 60 * 60 * 1000;

const days = (m, n) => Math.abs(m - n) / day;

const decay = (now, then) => Math.exp(-lambda * days(now, then));

const AUTHOR_PAT = /^Author:\s+(.+)\s+</;
const isAuthorLine = (line) => AUTHOR_PAT.test(line);
const getAuthor = (line) => AUTHOR_PAT.exec(line)[1];

const DATE_PAT = /^Date:\s+(.+)$/;
const isDateLine = (line) => DATE_PAT.test(line);
const getDate = (line) => DATE_PAT.exec(line)[1];

const isCodeFileLine =(line) => EDIT_PAT.test(line);
const getFile = (line) => EDIT_PAT.exec(line)[1];


const getAuthors =(lines) => (
  Array.from(new Set(lines.filter(x => isAuthorLine(x)).map(x => getAuthor(x))))
)

const getFiles = (lines) => (
  Array.from(new Set(lines.filter(x => isCodeFileLine(x)).map(x => getFile(x))))
);

const fileFrecency = (editHistory) => (
  Object.keys(editHistory).reduce((sum, author) => sum + editHistory[author].frecency, 0)
);

const isActiveContributor = (fileFrecency, authorEntry) => (
  authorEntry.frecency / fileFrecency >= THRESHOLD
);

const countActiveContributors = (frecency, editHistory) => {
  return count(Object.values(editHistory), entry => isActiveContributor(frecency, entry));
};

// add aggregate data:
//  - total edits, last edit, total frecency, number of serious contributors
const makeFileEntry = (file, editHistory) => {
  const frecency = fileFrecency(editHistory);
  const actives = countActiveContributors(frecency, editHistory);
  return { file, frecency, actives, authors: editHistory };
};

const getData = (text) => {
  const lines = text.split('\n');
  const authors = getAuthors(lines).sort();
  const fileNames = getFiles(lines);

  let date = null;
  let author = null;
  let latest = null;
  let decayedValue = 0;
  const editHistory = Object.fromEntries(fileNames.map(file => (
    [
      file,
      Object.fromEntries(authors.map(author => [author, { edits: [], frecency: 0 }]))
    ]
  )));

  // step through log generated by git log --no-merges --name-status
  // from newest to oldest commits to tally each author's edits for each file
  // with a time-decayed value relative to latest edit in the repo

  // TO-DO: handle deletes and renames
  lines.forEach(line => {
    if (isDateLine(line)) {
      date = getDate(line);
      latest ??= Date.parse(date);
      decayedValue = decay(latest, Date.parse(date));
    } else if (isAuthorLine(line)) {
      author = getAuthor(line);
    } else if (isCodeFileLine(line)) {
      const entry = editHistory[getFile(line)][author]
      entry.frecency += decayedValue;
      entry.edits.push(date);
    }
  });

  // create a list of entries organized by file with aggregate data
  const files =  Object.keys(editHistory)
    .map(file => makeFileEntry(file, editHistory[file]))
    .sort((entry1, entry2) => entry2.frecency - entry1.frecency);

  return { files, authors };
};

const loadFile = (file, callback) => {
  const reader = new FileReader();

  reader.addEventListener("load", () => {
    callback(reader.result);
  }, false);

  if (file) {
    reader.readAsText(file);
  }
};

export { getData, isActiveContributor, loadFile };