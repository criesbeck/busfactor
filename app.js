'use strict';

const count = (lst, fn) => (
  lst.reduce((n, x) => fn(x) ? n + 1 : n, 0)
);

// decay-based activity
const halfLife = 7;
const lambda = Math.log(2) / halfLife;
const day = 24 * 60 * 60 * 1000;

const days = (m, n) => Math.abs(m - n) / day;

const decay = (now, then) => Math.exp(-lambda * days(now, then));


const AUTHOR_PAT = /^Author:\s+(.+)\s+</;
const isAuthorLine = (line) => AUTHOR_PAT.test(line);
const getAuthor = (line) => AUTHOR_PAT.exec(line)[1];

const DATE_PAT = /^Date:\s+(.+)$/;
const isDateLine = (line) => DATE_PAT.test(line);
const getDate = (line) => DATE_PAT.exec(line)[1];

const EDIT_PAT = /^[ACM]\s+(.*[.](?:js|jsx|ts|tsx|css|html|yml))/;

// only track Add, Change, Modify to JavaScript, HTML, CSS, and YAML files
const isCodeFileLine =(line) => EDIT_PAT.test(line);
const getFile = (line) => EDIT_PAT.exec(line)[1];


const getAuthors =(lines) => (
  Array.from(new Set(lines.filter(x => isAuthorLine(x)).map(x => getAuthor(x))))
)

const getFiles = (lines) => (
  Array.from(new Set(lines.filter(x => isCodeFileLine(x)).map(x => getFile(x))))
);

const fileFrecency = (editHistory) => (
  Object.keys(editHistory).reduce((sum, author) => sum + editHistory[author].frecency, 0)
);

const countContributors = (frecency, editHistory) => {
  const threshold = .03; // at least 3% relative frecency to be a serious contributor
  return count(Object.values(editHistory), entry => entry.frecency/frecency >= threshold);
};

// add aggregate data:
//  - total edits, last edit, total frecency, number of serious contributors
const makeFileEntry = (file, editHistory) => {
  const frecency = fileFrecency(editHistory);
  const contributors = countContributors(frecency, editHistory);
  return { file, frecency, contributors, authors: editHistory };
};

const getData = (text) => {
  const lines = text.split('\n');
  const authors = getAuthors(lines);
  const fileNames = getFiles(lines);

  let date = null;
  let author = null;
  let now = new Date().getTime();
  let decayedValue = 0;
  const editHistory = Object.fromEntries(fileNames.map(file => (
    [
      file,
      Object.fromEntries(authors.map(author => [author, { edits: [], frecency: 0 }]))
    ]
  )));

  // step through log generated by git log --no-merges --name-status
  // from newest to oldest commits
  // to tally each author's time of edits for each file with a time-decayed value
  // TO-DO: handle deletes and renames
  lines.forEach(line => {
    if (isDateLine(line)) {
      date = getDate(line);
      decayedValue = decay(now, Date.parse(date));
    } else if (isAuthorLine(line)) {
      author = getAuthor(line);
    } else if (isCodeFileLine(line)) {
      const entry = editHistory[getFile(line)][author]
      entry.frecency += decayedValue;
      entry.edits.push(date);
    }
  });

  // create a list of entries organized by file with aggregate data
  const files =  Object.keys(editHistory)
    .map(file => makeFileEntry(file, editHistory[file]))
    .sort((entry1, entry2) => entry2.frecency - entry1.frecency);

  return { files, authors };
};

const loadFile = (file, callback) => {
  const reader = new FileReader();

  reader.addEventListener("load", () => {
    callback(reader.result);
  }, false);

  if (file) {
    reader.readAsText(file);
  }
};